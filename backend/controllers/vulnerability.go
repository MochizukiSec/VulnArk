package controllers

import (
	"context"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"vuln-management/config"
	"vuln-management/models"
	"vuln-management/services"
)

// VulnerabilityController 漏洞相关控制器
type VulnerabilityController struct {
	vulnService *services.VulnerabilityService
}

// NewVulnerabilityController 创建漏洞控制器
func NewVulnerabilityController(vulnService *services.VulnerabilityService) *VulnerabilityController {
	return &VulnerabilityController{
		vulnService: vulnService,
	}
}

// GetAllVulnerabilities 获取所有漏洞
func (c *VulnerabilityController) GetAllVulnerabilities(ctx *gin.Context) {
	// 获取查询参数
	var searchParams models.VulnerabilitySearchParams
	if err := ctx.ShouldBindQuery(&searchParams); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "无效的查询参数", "details": err.Error()})
		return
	}

	// 设置默认分页参数
	if searchParams.Page < 1 {
		searchParams.Page = 1
	}
	if searchParams.PerPage < 1 || searchParams.PerPage > 100 {
		searchParams.PerPage = 20
	}

	// 获取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	// 构建过滤条件
	filter := bson.M{}

	// 添加严重程度过滤
	if searchParams.Severity != "" {
		filter["severity"] = searchParams.Severity
	}

	// 添加状态过滤
	if searchParams.Status != "" {
		filter["status"] = searchParams.Status
	}

	// 添加负责人过滤
	if searchParams.AssignedTo != "" {
		assignedToID, err := primitive.ObjectIDFromHex(searchParams.AssignedTo)
		if err == nil {
			filter["assigned_to"] = assignedToID
		}
	}

	// 添加搜索条件
	if searchParams.SearchTerm != "" {
		filter["$or"] = []bson.M{
			{"title": bson.M{"$regex": searchParams.SearchTerm, "$options": "i"}},
			{"description": bson.M{"$regex": searchParams.SearchTerm, "$options": "i"}},
			{"cve": bson.M{"$regex": searchParams.SearchTerm, "$options": "i"}},
		}
	}

	// 计算总数
	total, err := vulnsCollection.CountDocuments(dbCtx, filter)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "计数漏洞失败", "details": err.Error()})
		return
	}

	// 设置排序
	sortField := "created_at"
	sortOrder := -1 // 默认降序
	if searchParams.SortBy != "" {
		sortField = searchParams.SortBy
	}
	if searchParams.SortOrder == "asc" {
		sortOrder = 1
	}

	// 设置查询选项
	opts := options.Find().
		SetSkip(int64((searchParams.Page - 1) * searchParams.PerPage)).
		SetLimit(int64(searchParams.PerPage)).
		SetSort(bson.D{{Key: sortField, Value: sortOrder}})

	// 执行查询
	cursor, err := vulnsCollection.Find(dbCtx, filter, opts)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "查询漏洞失败", "details": err.Error()})
		return
	}
	defer cursor.Close(dbCtx)

	// 解析漏洞数据
	var vulnerabilities []models.Vulnerability
	if err := cursor.All(dbCtx, &vulnerabilities); err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "解析漏洞数据失败", "details": err.Error()})
		return
	}

	// 构建响应
	totalPages := (total + int64(searchParams.PerPage) - 1) / int64(searchParams.PerPage)
	ctx.JSON(http.StatusOK, gin.H{
		"data": vulnerabilities,
		"meta": gin.H{
			"total":    total,
			"page":     searchParams.Page,
			"per_page": searchParams.PerPage,
			"pages":    totalPages,
		},
	})
}

// GetVulnerabilityByID 根据ID获取漏洞
func (c *VulnerabilityController) GetVulnerabilityByID(ctx *gin.Context) {
	// 獲取漏洞ID
	id := ctx.Param("id")
	vulnID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "無效的漏洞ID", "details": err.Error()})
		return
	}

	// 獲取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// 查詢漏洞
	var vulnerability models.Vulnerability
	err = vulnsCollection.FindOne(dbCtx, bson.M{"_id": vulnID}).Decode(&vulnerability)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			ctx.JSON(http.StatusNotFound, gin.H{"error": "漏洞不存在"})
		} else {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": "獲取漏洞失敗", "details": err.Error()})
		}
		return
	}

	// 返回漏洞詳情
	ctx.JSON(http.StatusOK, vulnerability)
}

// CreateVulnerability 创建漏洞
func (c *VulnerabilityController) CreateVulnerability(ctx *gin.Context) {
	// 解析请求体
	var vulnCreate models.VulnerabilityCreate
	if err := ctx.ShouldBindJSON(&vulnCreate); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "无效的请求格式", "details": err.Error()})
		return
	}

	// 获取当前用户ID
	userID, exists := ctx.Get("userID")
	if !exists {
		ctx.JSON(http.StatusUnauthorized, gin.H{"error": "用户未认证"})
		return
	}

	// 转换用户ID
	reportedByID, err := primitive.ObjectIDFromHex(userID.(string))
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "无效的用户ID", "details": err.Error()})
		return
	}

	// 获取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// 创建新漏洞对象
	now := time.Now()
	newVuln := models.Vulnerability{
		ID:               primitive.NewObjectID(),
		Title:            vulnCreate.Title,
		Description:      vulnCreate.Description,
		CVE:              vulnCreate.CVE,
		CVSS:             vulnCreate.CVSS,
		Severity:         vulnCreate.Severity,
		Status:           models.StatusOpen, // 默认为开放状态
		AffectedSystems:  vulnCreate.AffectedSystems,
		AffectedVersions: vulnCreate.AffectedVersions,
		Remediation:      vulnCreate.Remediation,
		References:       vulnCreate.References,
		DiscoveredAt:     now,
		ReportedAt:       now,
		ReportedBy:       reportedByID,
		Tags:             vulnCreate.Tags,
		Notes:            []models.Note{},
		Attachments:      []models.Attachment{},
		CreatedAt:        now,
		UpdatedAt:        now,
	}

	// 保存到数据库
	_, err = vulnsCollection.InsertOne(dbCtx, newVuln)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "创建漏洞失败", "details": err.Error()})
		return
	}

	// 返回成功响应
	ctx.JSON(http.StatusCreated, gin.H{
		"message": "漏洞创建成功",
		"data":    newVuln,
	})
}

// UpdateVulnerability 更新漏洞
func (c *VulnerabilityController) UpdateVulnerability(ctx *gin.Context) {
	// 獲取漏洞ID
	id := ctx.Param("id")
	vulnID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "無效的漏洞ID", "details": err.Error()})
		return
	}

	// 解析請求體
	var updateData map[string]interface{}
	if err := ctx.ShouldBindJSON(&updateData); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "無效的請求格式", "details": err.Error()})
		return
	}

	// 獲取當前用戶ID
	userID, exists := ctx.Get("userID")
	if !exists {
		ctx.JSON(http.StatusUnauthorized, gin.H{"error": "用戶未認證"})
		return
	}

	// 將用戶ID添加到更新的數據中
	updateUserID, _ := primitive.ObjectIDFromHex(userID.(string))
	updateData["updated_by"] = updateUserID
	updateData["updated_at"] = time.Now()

	// 如果更新狀態，設置相應的時間字段
	if status, ok := updateData["status"].(string); ok {
		switch status {
		case "resolved":
			updateData["resolved_at"] = time.Now()
		case "closed":
			updateData["closed_at"] = time.Now()
		}
	}

	// 創建歷史記錄
	history := bson.M{
		"action":    "update",
		"timestamp": time.Now(),
		"user_id":   updateUserID,
		"details":   "漏洞信息已更新",
	}

	// 獲取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// 準備更新文檔
	update := bson.M{
		"$set": updateData,
		"$push": bson.M{
			"history": history,
		},
	}

	// 執行更新
	result, err := vulnsCollection.UpdateOne(dbCtx, bson.M{"_id": vulnID}, update)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "更新漏洞失敗", "details": err.Error()})
		return
	}

	if result.MatchedCount == 0 {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "漏洞不存在"})
		return
	}

	// 返回成功響應
	ctx.JSON(http.StatusOK, gin.H{
		"message": "漏洞已成功更新",
	})
}

// DeleteVulnerability 删除漏洞
func (c *VulnerabilityController) DeleteVulnerability(ctx *gin.Context) {
	// 获取漏洞ID
	id := ctx.Param("id")
	vulnID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "无效的漏洞ID", "details": err.Error()})
		return
	}

	// 获取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// 执行删除操作
	result, err := vulnsCollection.DeleteOne(dbCtx, bson.M{"_id": vulnID})
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "删除漏洞失败", "details": err.Error()})
		return
	}

	// 检查是否成功删除
	if result.DeletedCount == 0 {
		ctx.JSON(http.StatusNotFound, gin.H{"error": "漏洞不存在"})
		return
	}

	// 返回成功响应
	ctx.JSON(http.StatusOK, gin.H{
		"message": "漏洞已成功删除",
	})
}

// ImportVulnerabilities 导入漏洞
func (c *VulnerabilityController) ImportVulnerabilities(ctx *gin.Context) {
	// 解析导入数据
	var importData models.VulnerabilityImport
	if err := ctx.ShouldBindJSON(&importData); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "无效的请求格式", "details": err.Error()})
		return
	}

	// 获取当前用户ID
	userID, exists := ctx.Get("userID")
	if !exists {
		ctx.JSON(http.StatusUnauthorized, gin.H{"error": "用户未认证"})
		return
	}

	// 转换用户ID
	reportedByID, err := primitive.ObjectIDFromHex(userID.(string))
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, gin.H{"error": "无效的用户ID", "details": err.Error()})
		return
	}

	// 获取漏洞集合
	vulnsCollection := config.GetCollection(config.VulnerabilitiesCollection)
	dbCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// 准备要插入的漏洞数据
	var vulnsToInsert []interface{}
	now := time.Now()

	for _, vuln := range importData.Vulnerabilities {
		// 设置必要的字段
		vuln.ID = primitive.NewObjectID()
		vuln.ReportedBy = reportedByID
		vuln.ReportedAt = now
		vuln.CreatedAt = now
		vuln.UpdatedAt = now

		// 设置状态为开放(如果未设置)
		if vuln.Status == "" {
			vuln.Status = models.StatusOpen
		}

		vulnsToInsert = append(vulnsToInsert, vuln)
	}

	// 执行批量插入
	if len(vulnsToInsert) > 0 {
		result, err := vulnsCollection.InsertMany(dbCtx, vulnsToInsert)
		if err != nil {
			ctx.JSON(http.StatusInternalServerError, gin.H{"error": "导入漏洞失败", "details": err.Error()})
			return
		}

		ctx.JSON(http.StatusCreated, gin.H{
			"message": "成功导入漏洞",
			"count":   len(result.InsertedIDs),
			"source":  importData.Source,
			"format":  importData.Format,
		})
	} else {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "没有有效的漏洞数据需要导入"})
	}
}
